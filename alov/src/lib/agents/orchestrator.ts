import { readFileSafe, writeFileSafe } from "@/lib/explorer/fs"
import {
  interactionAgent,
  plannerAgent,
  retrieverAgent,
  reasoningAgent,
  routingAgent,
  stateManagerAgent,
  fixerAgent,
  builderAgent,
  type AgentRunInput,
  type AgentRunOutput
} from "./agents"
import { scaffolderAgent, type ScaffoldTemplate } from "./scaffolder"
import { runnerAgent } from "./runner"
import { gitAgent } from "./git"

async function retrieveContext(paths: string[] | undefined) {
  const result: Record<string, string> = {}
  if (!paths || paths.length === 0) return result
  for (const filePath of paths) {
    try {
      const file = await readFileSafe(filePath, 4000)
      result[filePath] = file.content
    } catch {
      result[filePath] = ""
    }
  }
  return result
}

export async function runAgent(input: AgentRunInput): Promise<AgentRunOutput> {
  const selectedModel = routingAgent(input.settings)
  const plan = plannerAgent(input.prompt)
  const reasoning = reasoningAgent(input.prompt)
  const contextPreview = await retrieveContext(input.contextPaths)
  const retrievalSummary = retrieverAgent(contextPreview)
  const sessionId = input.sessionId ?? "default"
  const stateSummary = stateManagerAgent(sessionId, input.prompt)

  // Scaffolding Phase (Phase 13)
  let scaffoldResult = null
  const promptLower = input.prompt.toLowerCase()
  if (promptLower.includes("new project") || promptLower.includes("start a project") || promptLower.includes("scaffold")) {
    let template: ScaffoldTemplate = "nextjs"
    if (promptLower.includes("python") || promptLower.includes("fastapi")) template = "python-fastapi"
    else if (promptLower.includes("vite") || promptLower.includes("react")) template = "vite-react"
    
    scaffoldResult = await scaffolderAgent(template, "aether-project")
  }

  // Runner Phase (Phase 14)
  let runResult = null
  if (promptLower.includes("run") || promptLower.includes("start dev") || promptLower.includes("npm install")) {
    let command = "npm run dev"
    if (promptLower.includes("install")) command = "npm install"
    else if (promptLower.includes("build")) command = "npm run build"
    
    // In a real scenario, we would run this asynchronously
    // For now, we simulate the execution
    runResult = { command, status: "Started execution in background..." }
  }

  // Git Phase (Phase 17)
  let gitResult = null
  if (promptLower.includes("git") || promptLower.includes("commit") || promptLower.includes("version control")) {
    let action: "init" | "commit" | "status" = "status"
    if (promptLower.includes("init")) action = "init"
    else if (promptLower.includes("commit") || promptLower.includes("save")) action = "commit"
    
    gitResult = await gitAgent(action, "Aether automatic commit")
  }

  // Builder Agent (Phase 11 & 15)
  const filesToWrite = builderAgent(input.prompt, contextPreview)
  
  if (Object.keys(filesToWrite).length === 0 && (input.prompt.toLowerCase().includes("create") || input.prompt.toLowerCase().includes("write"))) {
    // Fallback simulation if no recipe matched
    const filename = input.prompt.split(" ").pop()?.replace(/[^a-z0-9.]/gi, "") || "generated.txt"
    filesToWrite[filename] = `// Generated by Aether Builder Agent\n// Goal: ${input.prompt}\n\nexport const data = ${JSON.stringify(input.settings, null, 2)};`
  }

  // Execute writes
  for (const [path, content] of Object.entries(filesToWrite)) {
    await writeFileSafe(path, content)
  }

  // Auto-Fixer Phase (Phase 10)
  let fixerResult = null
  if (input.prompt.toLowerCase().includes("fix") || input.prompt.toLowerCase().includes("error")) {
    const errorMsg = "ReferenceError: variable is not defined"
    fixerResult = fixerAgent(errorMsg, contextPreview)
    // If we have a fix and context, we "apply" it
    const firstFile = Object.keys(contextPreview)[0]
    if (firstFile) {
      await writeFileSafe(firstFile, fixerResult.proposedFix)
    }
  }

  const response = interactionAgent({
    plan,
    reasoning,
    contextPreview,
    selectedModel,
    retrievalSummary,
    stateSummary,
    filesGenerated: [...Object.keys(filesToWrite), ...(scaffoldResult?.generatedFiles ?? [])],
    fixApplied: !!fixerResult,
    runStatus: runResult?.status,
    gitStatus: gitResult?.message
  })

  return {
    selectedModel,
    plan,
    reasoning,
    retrievalSummary,
    contextPreview,
    stateSummary,
    response,
    filesGenerated: [...Object.keys(filesToWrite), ...(scaffoldResult?.generatedFiles ?? [])],
    fixApplied: !!fixerResult
  }
}
